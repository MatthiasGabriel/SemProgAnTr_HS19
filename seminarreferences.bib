@inproceedings{Cadar:2008:KUA:1855741.1855756,
 author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
 title = {KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs},
 booktitle = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
 series = {OSDI'08},
 year = {2008},
 location = {San Diego, California},
 pages = {209--224},
 numpages = {16},
 url = {http://dl.acm.org/citation.cfm?id=1855741.1855756},
 acmid = {1855756},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 

@inproceedings{Cadar:2006:EAG:1180405.1180445,
 author = {Cadar, Cristian and Ganesh, Vijay and Pawlowski, Peter M. and Dill, David L. and Engler, Dawson R.},
 title = {EXE: Automatically Generating Inputs of Death},
 booktitle = {Proceedings of the 13th ACM Conference on Computer and Communications Security},
 series = {CCS '06},
 year = {2006},
 isbn = {1-59593-518-5},
 location = {Alexandria, Virginia, USA},
 pages = {322--335},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/1180405.1180445},
 doi = {10.1145/1180405.1180445},
 acmid = {1180445},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {attack generation, bug finding, constraint solving, dynamic analysis, symbolic execution, test case generation},
} 


@InProceedings{10.1007/978-3-319-11194-0_12,
author="Chen, Ting
and Zhang, Xiao-song
and Chen, Rui-dong
and Yang, Bo
and Bai, Yang",
editor="Sun, Xian-he
and Qu, Wenyu
and Stojmenovic, Ivan
and Zhou, Wanlei
and Li, Zhiyang
and Guo, Hua
and Min, Geyong
and Yang, Tingting
and Wu, Yulei
and Liu, Lei",
title="Conpy: Concolic Execution Engine for Python Applications",
booktitle="Algorithms and Architectures for Parallel Processing",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="150--163",
abstract="Concolic execution has become a promising technique for program analysis in recent years, whereas it rarely applies to Python applications. In this work, we propose a concolic execution engine for Python applications named Conpy. Conpy is easy to deploy since it is written in pure Python and it is not dependent on any third-party tools. Conpy is also easy to use. Anyone with basic knowledge of Python and concolic execution can quickly get start with Conpy. Besides, Conpy works in low level and produces human-readable reports which facilitate subsequent analysis. We then make an elaborate performance testing on Conpy. Results show that the overhead of Conpy is acceptable, that is to say, less than one order of magnitude in most cases.",
isbn="978-3-319-11194-0"
}

@InProceedings{10.1007/11817963_38,
author="Sen, Koushik
and Agha, Gul",
editor="Ball, Thomas
and Jones, Robert B.",
title="CUTE and jCUTE: Concolic Unit Testing and Explicit Path Model-Checking Tools",
booktitle="Computer Aided Verification",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="419--423",
abstract="CUTE, a Concolic Unit Testing Engine for C and Java, is a tool to systematically and automatically test sequential C programs (including pointers) and concurrent Java programs. CUTE combines concrete and symbolic execution in a way that avoids redundant test cases as well as false warnings. The tool also introduces a race-flipping technique to efficiently test and model check concurrent programs with data inputs.",
isbn="978-3-540-37411-4"
}



@InProceedings{10.1007/978-3-642-22110-1_49,
author="Li, Guodong
and Ghosh, Indradeep
and Rajan, Sreeranga P.",
editor="Gopalakrishnan, Ganesh
and Qadeer, Shaz",
title="KLOVER: A Symbolic Execution and Automatic Test Generation Tool for C++ Programs",
booktitle="Computer Aided Verification",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="609--615",
abstract="We present the first symbolic execution and automatic test generation tool for C++ programs. First we describe our effort in extending an existing symbolic execution tool for C programs to handle C++ programs. We then show how we made this tool generic, efficient and usable to handle real-life industrial applications. Novel features include extended symbolic virtual machine, library optimization for C and C++, object-level execution and reasoning, interfacing with specific type of efficient solvers, and semi-automatic unit and component testing. This tool is being used to assist the validation and testing of industrial software as well as publicly available programs written using the C++ language.",
isbn="978-3-642-22110-1"
}

@article{SurveySymExec-CSUR18,
  author    = {Baldoni, Roberto and Coppa, Emilio and D'Elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  title     = {A Survey of Symbolic Execution Techniques},
  journal   = {ACM Comput. Surv.},
  volume    = {51},
  number = {3},
  articleno = {50},
  publisher = {ACM},
  address = {New York, NY, USA},
  year = {2018}
}

@article{Godefroid:2012:SWF:2090147.2094081,
 author = {Godefroid, Patrice and Levin, Michael Y. and Molnar, David},
 title = {SAGE: Whitebox Fuzzing for Security Testing},
 journal = {Queue},
 issue_date = {January 2012},
 volume = {10},
 number = {1},
 month = jan,
 year = {2012},
 issn = {1542-7730},
 pages = {20:20--20:27},
 articleno = {20},
 numpages = {8},
 url = {http://doi.acm.org/10.1145/2090147.2094081},
 doi = {10.1145/2090147.2094081},
 acmid = {2094081},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@article{Godefroid:2005:DDA:1064978.1065036,
 author = {Godefroid, Patrice and Klarlund, Nils and Sen, Koushik},
 title = {DART: Directed Automated Random Testing},
 journal = {SIGPLAN Not.},
 issue_date = {June 2005},
 volume = {40},
 number = {6},
 month = jun,
 year = {2005},
 issn = {0362-1340},
 pages = {213--223},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/1064978.1065036},
 doi = {10.1145/1064978.1065036},
 acmid = {1065036},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated test generation, interfaces, program verification, random testing, software testing},
} 
@inproceedings{Burnim:2008:HSD:1642931.1642995,
 author = {Burnim, J. and Sen, K.},
 title = {Heuristics for Scalable Dynamic Test Generation},
 booktitle = {Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering},
 series = {ASE '08},
 year = {2008},
 isbn = {978-1-4244-2187-9},
 pages = {443--446},
 numpages = {4},
 url = {http://dx.doi.org/10.1109/ASE.2008.69},
 doi = {10.1109/ASE.2008.69},
 acmid = {1642995},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {depth-first search strategy, scalable dynamic test generation, symbolic execution, software systems, path space, control flow graph, open source concolic testing tool, software tools},
} 


@article{doi:10.1002/sec.1290,
author = {Chen, Ting and Lin, Xiaodong and Huang, Jin and Bacchus, Abel and Zhang, Xiaosong},
title = {An empirical investigation into path divergences for concolic execution using CREST},
journal = {Security and Communication Networks},
volume = {8},
number = {18},
pages = {3667-3681},
keywords = {concolic execution, path divergences, prevalence, misleading inputs, divergent patterns, countermeasures},
doi = {10.1002/sec.1290},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/sec.1290},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/sec.1290},
abstract = {Abstract Recently, concolic execution has become a hotspot in the domain of software testing and program analysis. However, a practical challenge, called path divergence, impairs the soundness and completeness of concolic execution. A path divergence indicates the tested program runs an unpredicted path. In this work, we carry out a comprehensive empirical study on path divergences using an open-source concolic execution tool, named CREST. To make the investigation representative, we select 120 test units randomly from 21 different open-source programs. The results are interesting, and will provide insight to solve the challenging path-divergence problem. First, about one-half of test units suffer from path divergences, indicating path divergences are so prevalent that the issue is worthy of great attention. Second, quite a number of generated test inputs drive test units to take divergent paths. This means testers need considerable effort to eliminate the misleading test inputs before aggregating them to a test suite. Third, we dig out ten divergent patterns through manual analysis of each path divergence. Among them, the three most prevalent ones, which are exceptions, external calls, and type casts, lead to almost 82\% of path divergences. Finally, we discuss several countermeasures to overcome path divergences. Copyright Â© 2015 John Wiley \& Sons, Ltd.},
year = {2015}
}

@inproceedings{Ganesh:2007:DPB:1770351.1770421,
 author = {Ganesh, Vijay and Dill, David L.},
 title = {A Decision Procedure for Bit-vectors and Arrays},
 booktitle = {Proceedings of the 19th International Conference on Computer Aided Verification},
 series = {CAV'07},
 year = {2007},
 isbn = {978-3-540-73367-6},
 location = {Berlin, Germany},
 pages = {519--531},
 numpages = {13},
 url = {http://dl.acm.org/citation.cfm?id=1770351.1770421},
 acmid = {1770421},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
} 
@InProceedings{10.1007/978-3-540-24605-3_37,
author="E{\'e}n, Niklas
and S{\"o}rensson, Niklas",
editor="Giunchiglia, Enrico
and Tacchella, Armando",
title="An Extensible SAT-solver",
booktitle="Theory and Applications of Satisfiability Testing",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="502--518",
abstract="In this article, we present a small, complete, and efficient SAT-solver in the style of conflict-driven learning, as exemplified by Chaff. We aim to give sufficient details about implementation to enable the reader to construct his or her own solver in a very short time. This will allow users of SAT-solvers to make domain specific extensions or adaptions of current state-of-the-art SAT-techniques, to meet the needs of a particular application area. The presented solver is designed with this in mind, and includes among other things a mechanism for adding arbitrary boolean constraints. It also supports solving a series of related SAT-problems efficiently by an incremental SAT-interface.",
isbn="978-3-540-24605-3"
}

@inproceedings{Gomes2008SatisfiabilityS,
  title={Satisfiability Solvers},
  author={Carla P. Gomes and Henry A. Kautz and Ashish Sabharwal and Bart Selman},
  booktitle={Handbook of Knowledge Representation},
  year={2008}
}

@article{Cadar:2013:SES:2408776.2408795,
 author = {Cadar, Cristian and Sen, Koushik},
 title = {Symbolic Execution for Software Testing: Three Decades Later},
 journal = {Commun. ACM},
 issue_date = {February 2013},
 volume = {56},
 number = {2},
 month = feb,
 year = {2013},
 issn = {0001-0782},
 pages = {82--90},
 numpages = {9},
 url = {http://doi.acm.org/10.1145/2408776.2408795},
 doi = {10.1145/2408776.2408795},
 acmid = {2408795},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@inproceedings{Jackson:2004:CFC:2103144.2103160,
 author = {Jackson, Paul and Sheridan, Daniel},
 title = {Clause Form Conversions for Boolean Circuits},
 booktitle = {Proceedings of the 7th International Conference on Theory and Applications of Satisfiability Testing},
 series = {SAT'04},
 year = {2005},
 isbn = {3-540-27829-X, 978-3-540-27829-0},
 location = {Vancouver, BC, Canada},
 pages = {183--198},
 numpages = {16},
 url = {http://dx.doi.org/10.1007/11527695_15},
 doi = {10.1007/11527695_15},
 acmid = {2103160},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
} 
@InProceedings{10.1007/978-3-540-71209-1_28,
author="Bryant, Randal E.
and Kroening, Daniel
and Ouaknine, Jo{\"e}l
and Seshia, Sanjit A.
and Strichman, Ofer
and Brady, Bryan",
editor="Grumberg, Orna
and Huth, Michael",
title="Deciding Bit-Vector Arithmetic with Abstraction",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="358--372",
abstract="We present a new decision procedure for finite-precision bit-vector arithmetic with arbitrary bit-vector operations. Our procedure alternates between generating under- and over-approximations of the original bit-vector formula. An under-approximation is obtained by a translation to propositional logic in which some bit-vector variables are encoded with fewer Boolean variables than their width. If the under-approximation is unsatisfiable, we use the unsatisfiable core to derive an over-approximation based on the subset of predicates that participated in the proof of unsatisfiability. If this over-approximation is satisfiable, the satisfying assignment guides the refinement of the previous under-approximation by increasing, for some bit-vector variables, the number of Boolean variables that encode them. We present experimental results that suggest that this abstraction-based approach can be considerably more efficient than directly invoking the SAT solver on the original formula as well as other competing decision procedures.",
isbn="978-3-540-71209-1"
}
@article{Chipounov:2012:SPD:2110356.2110358,
 author = {Chipounov, Vitaly and Kuznetsov, Volodymyr and Candea, George},
 title = {The S2E Platform: Design, Implementation, and Applications},
 journal = {ACM Trans. Comput. Syst.},
 issue_date = {February 2012},
 volume = {30},
 number = {1},
 month = feb,
 year = {2012},
 issn = {0734-2071},
 pages = {2:1--2:49},
 articleno = {2},
 numpages = {49},
 url = {http://doi.acm.org/10.1145/2110356.2110358},
 doi = {10.1145/2110356.2110358},
 acmid = {2110358},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Symbolic execution, analysis, profiling, testing},
} 


@article{Davis:1960:CPQ:321033.321034,
 author = {Davis, Martin and Putnam, Hilary},
 title = {A Computing Procedure for Quantification Theory},
 journal = {J. ACM},
 issue_date = {July 1960},
 volume = {7},
 number = {3},
 month = jul,
 year = {1960},
 issn = {0004-5411},
 pages = {201--215},
 numpages = {15},
 url = {http://doi.acm.org/10.1145/321033.321034},
 doi = {10.1145/321033.321034},
 acmid = {321034},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
@article{Davis:1962:MPT:368273.368557,
 author = {Davis, Martin and Logemann, George and Loveland, Donald},
 title = {A Machine Program for Theorem-proving},
 journal = {Commun. ACM},
 issue_date = {July 1962},
 volume = {5},
 number = {7},
 month = jul,
 year = {1962},
 issn = {0001-0782},
 pages = {394--397},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/368273.368557},
 doi = {10.1145/368273.368557},
 acmid = {368557},
 publisher = {ACM},
 address = {New York, NY, USA},
} 
