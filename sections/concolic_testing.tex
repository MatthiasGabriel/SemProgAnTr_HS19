\section{Concolic Testing} \label{section:concolic_testing}
Concolic execution tries to overcome the restriction of symbolic execution, that were discussed in \ref{section:symbolic_restrictions}. There are many different approaches to do this, but all of them have in common, that they trade in some of the completeness to be able to complete at least a partial analysis of the program.
On the basis of KLEE \cite{Cadar:2008:KUA:1855741.1855756} one possible approach to these two problems will be presented in this section.

KLEE only works on programs that are first compiled into the LLVM an assembly language, this is normally done by using the compiler Clang \footnote{Clang is currently able to compile C, C++  and Objective-C programs into LLVM}. 
Each of the states that we saw in the previous examples \ref{fig:sym_example_one} and \ref{fig:sym_tree_loop} has the properties $\sigma$, now called heap, and $\pi$, which is called path condition. Additionally each state has a register file, a stack, a program counter. Based on the current instruction that is processed KLEE modifies $\sigma$ or $\pi$.

If the statement needs a modification of $\sigma$, the instruction gets mapped into an identitcal symbolic instruction. For most instructions the symbolic execution is trivial. For example the result of an addition of two symbolic values just saves that the new variable is the addition of the two values.\todo{non trivial instructions} Note however that KLEE executes the operation directly if all input values are concrete and therefore assigns a new concrete value to the variable.

If it is a branching statement $\pi_{true}$ aswell as $\pi_{false}$ are calcuated and duplication of the current state takes place after the two $\pi$ are checked for feasability in combination with the current path condition.

In addition to branching statements each potentially dangerous operation, such as pointer dereferencing or division, generates a new branch too. With this additional branching step it's possible to automatically check if any input is possible, that results in an invalid operation. This state never has a subtree attached, because if the path condition is infeasable the execution stops automatically, before the branching actually takes place and if it's feasable an error is raised resulting in the cancelation of this subtree. On the other branch the negative of the condition is added to prevent the error in this state and be able to continue the analysis of the program.

The only special case of these dangerous operations are loading and storing operations. KLEE maps every object to an SPT specific array. This enables SPT to ignore the parts of the state date, which are not directly related to the expression that gets evaluated. Because it could be possible that a "symbolic" pointer refer to different objects, the state will be cloned for each of the objects as soon as the pointer gets dereferenced. With the cloning it can be ensured that in every state the pointer references exactly one specific object. This may seem very pricy, as for each possible object a new state has to be created. However in reality semantic pointer to multiple objects rarely happen. \todo{describe copy-on-write} \todo{describe constraint solving optimization and caching} \todo{describe search strategies which prevent starvation due to loops} \todo{describe file system "mock"} \todo{describe that testcases are generated which can be used to execute to original code}


\todo{maybe add tool equivalence, but it is in my opinion a rarely used scenario}
\todo{Cleanup}
What is concolic testing? How does concolic testing work? Why do we need concolic execution? What "problems" and limits of symbolic execution does it solve and what are the new limitations that arise?
What are the differences, advantages and disadvantages in relation to symbolic execution.
\cite{Cadar:2006:EAG:1180405.1180445}
\cite{Cadar:2008:KUA:1855741.1855756}
\cite{Cadar:2013:SES:2408776.2408795}
\cite{Godefroid:2005:DDA:1064978.1065036}
\cite{Godefroid:2012:SWF:2090147.2094081}