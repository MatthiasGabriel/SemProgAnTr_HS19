\section{Symbolic Execution}
Symbolic execution is method how to analyse a program. First researchs in this area were done around 1975. One of its main goals is to find certain programming errors, another possible goal is to prove that two programs handle each input exactly the same way. As you can image both of this problems are non trivial. In this publication the focus is on finding programming errors and other parts of symbolic execution might get pointed out, but will not be discussed in detail. 

Symbolic execution focuses on problems that can not be determined by static code analysis, because they require the execution of the program. In contradiction to a normal execution, for example in manual unit tests, random fuzzing or even actual user input, this analysis uses so called symbolic input.

In contrast to a variable with a concrete value, for example 5, a variable with a symbolic value can have any value. This symbolic value will get certain restrictions during the execution of the program. During the execution of the program the execution engine will track all assigned variables. This collection of variables is called symbolic memory store and $\sigma$ will be used to denote it in mathematical terms.\cite{SurveySymExec-CSUR18}.
Whenever a variable gets a new value, the variable and its value will be added to the memory store. If the variable is based on a variable with a symbolic value then the new variable will also get a symbolic value. If its based on a conrecte value then the concrete value itself will be stored.

Consider the following example where the variables a and b are symbolic and the according values denoted with the symbols $\alpha_a$ and $\alpha_b$:
$$\sigma = \{a\gets \alpha_a , b \gets \alpha_b\}$$
If we assign a new variable c = 2*a the memory store will be updated to include c and thus be
$$\sigma = \{a\gets \alpha_a , b \gets \alpha_b, c \gets 2*\alpha_a\}$$
If we assign the value $1$ to the variable a $a = 1$ then the memory store will get updated too. Note that the symbolic value $\alpha_a$ stays in the variable c, as this assignment has been made before the variable $a$ got a new value.
$$\sigma = \{a\gets 1, b \gets \alpha_b, c \gets 2*\alpha_a\}$$


Whenever a branching statement\footnote{For example the if-statement or switch-statement} is reached that depends on a symbolic value, the symbolic execution engine must follow both of the branches and restrict the symbolic value in regard to the condition. These restrictions are collected and together describe all conditions that the symbolic variables must satisfy in this specific branch. This collection is often called path condition or path constraints and $\pi$ used to denote it\cite{SurveySymExec-CSUR18}.
Consider for example that a statement $if (a > 0)$ is the first statement of your code. Because this is a branching statement the execution engine has to calucate two different path constraints $\pi_{true}$ and $\pi_{false}$
$$\pi_{true} = \alpha_a > 0$$
$$\pi_{false} = \alpha_a <= 0$$

Directly after the branching the path condition can be handed to an SMT solver, which will try to find concrete values to all the variables in the symbolic memory store, so that the condition is satisfied. If the SMT solver decides that a condition is not satisfiable this path of the pogram does not need further research, as it can no be reached.

\begin{codesnippet}[caption={Simple Symbolic Execution Example}, label={codeSnippet:symbolicExecution}]
int calculateMagicNumber(int a, int b){
   int x = 1;
   if(a >= 0){
      if (b > 0){
         a = a + x;
      }
      if(b < 0){
        a = (a+1)*b;
      }
   }else{
     a = a*-1;
   }
  assert(a != 0);
  return b / a
}
\end{codesnippet}
\begin {figure*}%[!hbtp]
\begin{adjustbox}{width=\textwidth}
\begin{tikzpicture}[
    grow=down,
  baseline,
  level distance=35mm,
  text depth=.1em,
  text height=.8em,
  scale = 1.5,
  level 1/.style={sibling distance=10em},
  level 2/.style={sibling distance=45em},
  level 3/.style={sibling distance=41em},
  level 4/.style={sibling distance=20em},
    edge from parent/.style={very thick,draw=blue!40!black!60,
        shorten >=5pt, shorten <=5pt},
    edge from parent path={(\tikzparentnode.south) -- (\tikzchildnode.north)},
    kant/.style={text width=2cm, text centered, sloped},
    every node/.style={text ragged, inner sep=2mm},
    punkt/.style={rectangle, rounded corners, shade, top color=white,
    bottom color=blue!50!black!20, draw=blue!40!black!60, very
    thick }
    ]

\node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
   	 \textbf{State A}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,\highlight{x\gets 1}\}$, $\pi = true$
                  \nodepart{third}
	Line 1: x = 1
}
    child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
   	 \textbf{State B}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi = true$
		\nodepart{third}
	 Line 2: if($a \geq	0$)
        }
        child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State C}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi = \highlight{\alpha_a \geq 0} $
		\nodepart{third}
	Line 3: if($b > 0$)
        }
        child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State D}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi =  \alpha_a \geq 0 \land \highlight{\alpha_b > 0}$
		\nodepart{third}
	Line 5: $a = a + x$
        }
	 child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
		\textbf{State E}
	                  \nodepart{second}
	            $\sigma = \{\highlight{a\gets \alpha_a +1}, b \gets \alpha_b\,x\gets 1\}$, $\pi =  \alpha_a \geq 0 \land \alpha_b > 0$
			\nodepart{third}
		Line 7: if($b<0$)
	        }
		 child {
		        node[punkt] [rectangle split, rectangle split, rectangle split parts=1, text ragged] {
		            $\pi =  \alpha_a \geq 0 \land \alpha_b > 0 \land \alpha_b < 0 \Leftrightarrow \text{not satisfiable}$
		        }
		        edge from parent
		            node[kant, below, pos=.6] {$b<0$}}
 		child {
		        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
			\textbf{State F}
		                  \nodepart{second}
		            $\sigma = \{a\gets \alpha_a +1, b \gets \alpha_b\,x\gets 1\}$, $\pi =  \alpha_a \geq 0 \land \alpha_b > 0 \land \highlight{b \geq 0}$
				\nodepart{third}
			Line 13: $assert(a!=0)$
		        }
			  child {
			        node[punkt] [rectangle split, rectangle split, rectangle split parts=1, text ragged] {
				\textbf{$\alpha_a+1 = 0 \land \alpha_a \geq 0 \land \alpha_b \leq 0 \land \alpha_b < 0 \land b \geq 0 \Leftrightarrow false$}
			        }
		        edge from parent
		            node[kant, below, pos=.6] {}}
		        edge from parent
		            node[kant, below, pos=.6] {$b \geq 0$}}
	        edge from parent
	            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {$b > 0$}}	
        child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State G}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi = \alpha_a \geq 0 \land \highlight{\alpha_b \leq 0}$
		\nodepart{third}
	Line 7: if($b < 0$)
        }
        child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State H}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a, b \gets \alpha_b\,x\gets 1\}$, $\pi = \alpha_a \geq 0 \land \alpha_b \leq 0 \land \highlight{\alpha_b < 0}$
		\nodepart{third}
	Line 8: $a=(a+1)*b$
        }
 child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State I}
                  \nodepart{second}
            $\sigma = \{\highlight{a\gets (\alpha_a+1)*\alpha_b} , b \gets \alpha_b\,x\gets 1\}$, $\pi = \alpha_a \geq 0 \land \alpha_b \leq 0 \land \alpha_b < 0$
		\nodepart{third}
	Line 13: $assert(a!=0)$
        }
        child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=1, text ragged] {
		\textbf{$(\alpha_a+1)*\alpha_b  = 0 \land  \alpha_a \geq 0 \land \alpha_b \leq 0 \land \alpha_b < 0 \Leftrightarrow false$}
	        }
        edge from parent
            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {$b < 0$}}
        child {
        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
	\textbf{State J}
                  \nodepart{second}
            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi = \alpha_a \geq 0 \land \alpha_b \leq 0 \land \highlight{b \geq 0}$
		\nodepart{third}
	Line 13: $assert(a!=0)$
        }
        child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=1, text ragged] {
		\textbf{$\alpha_a  = 0 \land \alpha_a \geq 0 \land \alpha_b \leq 0 \land b \geq 0 \Leftrightarrow true$}
	        }
        edge from parent
            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {$b \geq 0$}}
        edge from parent
            node[kant, below, pos=.6] {$b \leq 0$}}	
        edge from parent
            node[kant, below, pos=.6] {$a \geq 0$}}
child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
		\textbf{State K}
	                  \nodepart{second}
	            $\sigma = \{a\gets \alpha_a , b \gets \alpha_b\,x\gets 1\}$, $\pi = \highlight{\alpha_a<0}$
			\nodepart{third}
		Line 11: $a = a * -1$
	        }
	 child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=3, text ragged] {
		\textbf{State L}
	                  \nodepart{second}
	            $\sigma = \{\highlight{a\gets \alpha_a * -1} , b \gets \alpha_b\,x\gets 1\}$, $\pi = \alpha_a<0$
			\nodepart{third}
		Line 13: $assert(a!=0)$
	        }
	 child {
	        node[punkt] [rectangle split, rectangle split, rectangle split parts=1, text ragged] {
		\textbf{$\alpha_a * -1 = 0 \land \alpha_a<0 \Leftrightarrow false$}
	        }
        edge from parent
            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {}}
        edge from parent
            node[kant, below, pos=.6] {$a < 0$}}	
        edge from parent
            node[kant, below, pos=.6] {}
    } ;

\end{tikzpicture}
\end{adjustbox}
\caption{Example of a symbolic execution tree based on the function displayed in codesnippet \ref{codeSnippet:symbolicExecution}}
\label{fig:sym_example_one}
\end{figure*}
\todo{Add last statement to tree}
This process is visualized in figure \ref{fig:sym_example_one} for the codesnippet \ref{codeSnippet:symbolicExecution}. Assume that someone had written the function $calculateMagicNumber$ which takes two integer arguments $a$ and $b$ and calculates a magic number. This magic number should meet certain criteria, amongst other things the number b is devided by a mutated a. Therefore the person added an assertion criteria which checks that $a$ is not $0$ to prevent a division by 0 and therefore an error state of the program. Symbolic execution is now capable to determine if there are any input values $a$  and $b$ that violate this assertion.


Introduction to the topic of symbolic execution and its limits \cite{SurveySymExec-CSUR18} . Information about symbolic execution is also included in nearly all sources listed in the section concolic testing\todo{Cleanup}